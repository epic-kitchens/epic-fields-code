import sys
import os
import os.path as osp
from pathlib import Path
import subprocess
import logging
import pycolmap


def parse_args():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('video_path', type=str)
    return parser.parse_args()


def setup_logger(name, log_file, level=logging.DEBUG):
    """To setup as many loggers as you want"""

    handler = logging.FileHandler(log_file, mode='a')
    formatter = logging.Formatter('%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',
                         datefmt='%Y-%m-%d %H:%M:%S')
    handler.setFormatter(formatter)
    logger = logging.getLogger(name)
    logger.setLevel(level)
    logger.addHandler(handler)

    return logger


class PipelineExecutor:
    """
    Output structure we need are:

    <out_dir>/
        pipeline.log
        sparse.log
        register.log
        dense_pcd.log
        colmap/
            sparse/{max_model_id}/{cameras.bin,points.bin,images.bin}
            registered/{cameras.bin,points.bin,images.bin}
            dense/dense.ply
    """

    def __init__(self, 
                 video_path: str, 
                 out_dir: str,
                 longside: int = 512,
                 camera_model: str = 'OPENCV', 
                 make_log_and_dirs=True,
                 ):
        """
        Args:
            video_path: path to the video
            camera_model: See Colmap doc
            longside: this controls the frame resolution for the extracted frames
        """
        self.worker_dir = Path(out_dir)
        self.video_file = video_path
        self.camera_model = camera_model
        self.longside = longside

        self.frames_dir = self.worker_dir / 'frames'
        self.homo_path = self.worker_dir / 'homo90.txt'
        self.colmap_dir = self.worker_dir / 'colmap'
        self.pipeline_log = self.worker_dir / 'pipeline.log'
        self.sparse_log = self.worker_dir / 'sparse.log'
        self.register_log = self.worker_dir / 'register.log'
        self.dense_pcd_log = self.worker_dir / 'dense_pcd.log'

        self.sparse_dir = self.colmap_dir / 'sparse'  # generated by colmap
        self.register_dir = self.colmap_dir / 'registered'
        self.dense_pcd_dir = self.colmap_dir / 'dense'

        if not make_log_and_dirs:
            return
        os.makedirs(self.worker_dir, exist_ok=True)
        self.logger = setup_logger('demo-logger', self.pipeline_log)
        self.logger.info("Run start")
        assert os.path.exists(self.pipeline_log)

    def extract_frames(self, with_skip=True):
        # num_expected_frames = -1
        if with_skip and os.path.exists(self.frames_dir) and len(os.listdir(self.frames_dir)) > 0:
            print(f'{self.frames_dir} exist and is non-empty, skip')
            return

        cmd1 = [
            'ffprobe', '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=width,height', '-of', 'csv=s=x:p=0', self.video_file
        ]
        # extract output resolution
        p = subprocess.Popen(cmd1, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        print('Original resolution: ', out)
        w, h = out.decode('utf-8').strip().split('x')
        h, w = int(h), int(w)
        assert w > h
        h = h * self.longside // w
        w = self.longside

        s = f'{w}x{h}'
        os.makedirs(self.frames_dir, exist_ok=True)

        print("Extracting frames... ")
        cmd2 = [
            'ffmpeg', '-i', self.video_file, '-q:v', '1', '-vf', 'fps=30', '-s', s, f'{self.frames_dir}/frame_%010d.jpg']
        cmd2 = ' '.join(cmd2)
        p = subprocess.call(cmd2, shell=True)
        self.logger.info(f'Extract frames done')

    def run_homography(self):
        self.logger.info(f'Run homography')
        cmd = [ 
            'python', 'homography_filter/filter.py', '--src',
            str(self.frames_dir), '--dst_file', str(self.homo_path), '--overlap', '0.9'
        ] 
        print(' '.join(cmd))
        if os.path.exists(self.homo_path):
            with open(self.homo_path, 'r') as fp:
                lines = fp.readlines()
            n_lines = len(lines)
            print(f'{self.homo_path} with {n_lines}, skip')
            self.logger.info(f'{self.homo_path} with {n_lines}, skip')
            return
        cmd = ' '.join(cmd)
        self.logger.info(cmd)
        p = subprocess.call(cmd, shell=True)
        self.logger.info(f'Homography Done')

    def run_sparse_reconstruct(self, script_path='demo/reconstruct_sparse.sh'):
        status = self.get_summary()
        if status['num_sparse_models'] > 0:
            self.logger.info(f'Found {status["num_sparse_models"]} sparse models, skip sparse reconstruction()')
            print(f'Found {status["num_sparse_models"]} sparse models, skip sparse reconstruction()')
            return
        self.logger.info(f'Run sparse')
        cmd = [
            'bash', script_path,
            str(self.worker_dir), str(self.camera_model)
        ]
        print(' '.join(cmd))
        print('Check sparse log at ', self.sparse_log)
        self.logger.info(' '.join(cmd))
        with open(self.sparse_log, 'w') as sparse_fp:
            p = subprocess.run(cmd, stdout=sparse_fp, stderr=sparse_fp)
        # out, err = p.communicate()
        if p.returncode != 0:
            print(f'Error in sparse reconstruction. See {self.sparse_log}')
            sys.exit(1)
        self.logger.info(f'Done sparse')

    def run_register(self, script_path='demo/register_dense.sh'):
        summary = self.get_summary()
        max_sparse_ind = summary['max_sparse_ind']
        if summary['num_register'] > 0:
            print(f'Found {summary["num_register"]} already registered, skiping')
            return
        self.logger.info(f'Run Register')
        cmd = [
            'bash', script_path,
            str(self.worker_dir), str(self.camera_model), str(max_sparse_ind)
        ]
        print(' '.join(cmd))
        self.logger.info(' '.join(cmd))
        with open(self.register_log, 'w') as register_fp:
            p = subprocess.run(cmd, stdout=register_fp, stderr=register_fp)
        self.logger.info(f'Done Register')

    def run_dense_pcd(self, script_path='demo/dense_point_cloud.sh'):
        summary = self.get_summary()
        max_sparse_ind = summary['max_sparse_ind']
        if os.path.exists(self.dense_pcd_dir / 'fused.ply'):
            print(f'fused.ply already exist in {self.dense_pcd_dir}, skiping')
            return
        self.logger.info(f'Run Dense PCD (patch stereo)')
        cmd = [
            'bash', script_path,
            str(self.worker_dir), str(max_sparse_ind)
        ]
        print(' '.join(cmd))
        self.logger.info(' '.join(cmd))
        with open(self.dense_pcd_log, 'w') as dense_pcd_fp:
            p = subprocess.run(cmd, stdout=dense_pcd_fp, stderr=dense_pcd_fp)
        self.logger.info(f'Done Dense PCD')

    def execute(self):
        self.extract_frames()
        self.run_homography()
        if not osp.exists(self.homo_path):
            print(f'{self.homo_path} not exist after homography, abort')
            return
        self.run_sparse_reconstruct()
        if not self.get_summary()['num_sparse_models'] > 0:
            print(f"num_sparse_models <= 0 after sparse reconstruction, abort")
            return
        self.run_register()
        self.run_dense_pcd()
    
    def get_summary(self) -> dict:
        """
        N-frames, N-homo, N-sparse-models, max_sparse_ind, N-sparse-images, N-register
        """
        info = dict(
            video=self.video_file,
            num_frames=-1, num_homo=-1, num_sparse_models=-1,
            max_sparse_ind=-1, num_sparse_images=-1, num_register=-1
        )
        info['num_frames'] = len(os.listdir(self.frames_dir))
        if not os.path.exists(self.homo_path):
            return info

        with open(self.homo_path) as fp:
            info['num_homo'] = len(fp.readlines())
    
        if not osp.exists(self.sparse_dir):
            return info

        info['num_sparse_models'] = len(os.listdir(self.sparse_dir))
        for mod in os.listdir(self.sparse_dir):
            mod_path = osp.join(self.sparse_dir, mod)
            recon = pycolmap.Reconstruction(mod_path)
            num_images = recon.num_images()
            if num_images > info['num_sparse_images']:
                info['num_sparse_images'] = num_images
                info['max_sparse_ind'] = mod  # str

        reg_path = osp.join(self.register_dir)
        if not osp.exists(osp.join(reg_path, 'images.bin')):
            return info
        recon = pycolmap.Reconstruction(reg_path)
        num_images = recon.num_images()
        info['num_register'] = num_images
        
        return info

if __name__ == '__main__':
    args = parse_args()
    executor = PipelineExecutor(
        args.video_path, out_dir='outputs/demo/',
        longside=512)
    executor.execute()